package game

import (
	"fmt"
	"image/color"

	"github.com/hajimehoshi/ebiten/v2"
)

// fontGlyphs defines a minimal 5x7 pixel font.
// Each rune maps to 7 rows, where each uint8's lower 5 bits are the pixels.
var fontGlyphs = map[rune][7]uint8{
	'0': {0x0E, 0x11, 0x13, 0x15, 0x19, 0x11, 0x0E},
	'1': {0x04, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x0E},
	'2': {0x0E, 0x11, 0x01, 0x06, 0x08, 0x10, 0x1F},
	'3': {0x0E, 0x11, 0x01, 0x06, 0x01, 0x11, 0x0E},
	'4': {0x02, 0x06, 0x0A, 0x12, 0x1F, 0x02, 0x02},
	'5': {0x1F, 0x10, 0x1E, 0x01, 0x01, 0x11, 0x0E},
	'6': {0x06, 0x08, 0x10, 0x1E, 0x11, 0x11, 0x0E},
	'7': {0x1F, 0x01, 0x02, 0x04, 0x08, 0x08, 0x08},
	'8': {0x0E, 0x11, 0x11, 0x0E, 0x11, 0x11, 0x0E},
	'9': {0x0E, 0x11, 0x11, 0x0F, 0x01, 0x02, 0x0C},
	'A': {0x0E, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x11},
	'C': {0x0E, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0E},
	'E': {0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x1F},
	'G': {0x0E, 0x11, 0x10, 0x17, 0x11, 0x11, 0x0E},
	'H': {0x11, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x11},
	'I': {0x0E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E},
	'L': {0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F},
	'M': {0x11, 0x1B, 0x15, 0x15, 0x11, 0x11, 0x11},
	'O': {0x0E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E},
	'P': {0x1E, 0x11, 0x11, 0x1E, 0x10, 0x10, 0x10},
	'R': {0x1E, 0x11, 0x11, 0x1E, 0x14, 0x12, 0x11},
	'S': {0x0E, 0x11, 0x10, 0x0E, 0x01, 0x11, 0x0E},
	'U': {0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E},
	'V': {0x11, 0x11, 0x11, 0x11, 0x0A, 0x0A, 0x04},
	'Y': {0x11, 0x11, 0x0A, 0x04, 0x04, 0x04, 0x04},
	'!': {0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x04},
	' ': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	'D': {0x1C, 0x12, 0x11, 0x11, 0x11, 0x12, 0x1C},
	'N': {0x11, 0x19, 0x15, 0x13, 0x11, 0x11, 0x11},
	'T': {0x1F, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04},
	'W': {0x11, 0x11, 0x11, 0x15, 0x15, 0x1B, 0x11},
	'X': {0x11, 0x11, 0x0A, 0x04, 0x0A, 0x11, 0x11},
}

const (
	fontWidth  = 5
	fontHeight = 7
	fontGap    = 1 // 1 pixel gap between characters
)

// DrawText renders text on screen using the pixel font.
func DrawText(screen *ebiten.Image, text string, x, y int, c color.Color) {
	curX := x
	for _, ch := range text {
		glyph, ok := fontGlyphs[ch]
		if !ok {
			curX += fontWidth + fontGap
			continue
		}
		for row := 0; row < fontHeight; row++ {
			for col := 0; col < fontWidth; col++ {
				if glyph[row]&(1<<(fontWidth-1-col)) != 0 {
					screen.Set(curX+col, y+row, c)
				}
			}
		}
		curX += fontWidth + fontGap
	}
}

// DrawHUD renders the score, high score, lives, and level.
func DrawHUD(screen *ebiten.Image, score, highScore, lives, level int) {
	white := color.RGBA{R: 0xFF, G: 0xFF, B: 0xFF, A: 0xFF}

	// Top area: score and high score
	DrawText(screen, "1UP", 2, 0, white)
	DrawText(screen, "HIGH SCORE", 72, 0, white)

	scoreStr := fmt.Sprintf("%d", score)
	DrawText(screen, scoreStr, 2, 9, white)

	highScoreStr := fmt.Sprintf("%d", highScore)
	DrawText(screen, highScoreStr, 96, 9, white)

	// Bottom area: lives and level
	bottomY := (HUDTopRows + MazeRows) * TileSize
	for i := 0; i < lives-1; i++ { // -1 because current life isn't shown
		// Draw small Pac-Man icon for each extra life
		op := &ebiten.DrawImageOptions{}
		op.GeoM.Scale(0.6, 0.6)
		op.GeoM.Translate(float64(2+i*10), float64(bottomY+2))
		screen.DrawImage(sprites.PacManFrames[1], op)
	}

	levelStr := fmt.Sprintf("LEVEL %d", level)
	DrawText(screen, levelStr, 156, bottomY+4, white)
}
